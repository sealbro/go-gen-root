package generator

import (
	"github.com/dave/jennifer/jen"
	"github.com/sealbro/go-gen-root/internal/injection"
	"path/filepath"
	"slices"
)

type Params struct {
	AppName     string
	ModuleName  string
	PackageName string
}

func Generate(params Params, injectObjects map[injection.StructInfo]*injection.InjectObject) (string, error) {
	f := jen.NewFile(params.PackageName)
	f.PackageComment("Composition root code generated by github.com/sealbro/go-gen-root. DO NOT EDIT.")

	var appFields []jen.Code

	for _, v := range injectObjects {
		join := filepath.Join(params.ModuleName, v.FilePath)
		dir := filepath.Dir(join)
		appFields = append(appFields, jen.Id(v.CamelCaseStructName()).Op("*").Qual(dir, v.StructName))
	}

	f.Type().Id(params.AppName).Struct(appFields...)

	variables := make([]jen.Code, 0, len(injectObjects)+1)

	injectObjectsSlice := make([]*injection.InjectObject, 0, len(injectObjects))
	for _, v := range injectObjects {
		injectObjectsSlice = append(injectObjectsSlice, v)
	}

	injectObjectsSlice = slices.SortedFunc(slices.Values(injectObjectsSlice), func(i, j *injection.InjectObject) int {
		if len(i.Deps) < len(j.Deps) {
			return -1
		} else if len(i.Deps) > len(j.Deps) {
			return 1
		}
		return 0
	})

	for _, v := range injectObjectsSlice {
		params := make([]jen.Code, 0, len(v.Deps))
		for _, dep := range v.Deps {
			params = append(params, jen.Id(dep.CamelCaseStructName()))
		}

		variables = append(variables, jen.Add().Id("").Id(v.CamelCaseStructName()).Op(":=").Id(v.FuncFullName()).Call(params...))
	}

	f.Func().Id("New" + params.AppName).Params().Id("*" + params.AppName).Block(
		append(variables,
			jen.Return(jen.Op("&").Id(params.AppName).Values(jen.DictFunc(func(d jen.Dict) {
				for _, v := range injectObjects {
					d[jen.Id(v.CamelCaseStructName())] = jen.Id(v.CamelCaseStructName())
				}
			}))))...)

	return f.GoString(), nil
}
